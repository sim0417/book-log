# TIL / 2장 타입스크립트의 타입 시스템 part.2 / 2023.05.19

## 🍎 오늘 읽은 내용

- 아이템 9: 타입 단언 보다는 타입 선언을 사용하기
- 아이템 10: 객체 래퍼 타입 피하기
- 아이템 11: 잉여 속성 체크의 한계 인지하기

## 📔 메모

### 타입 단언 보다는 타입 선언을 사용하기

- 타입선언을 사용하는것이 더 나은 이유는 아래와 같습니다.

```ts
interface Person { name: string };
const alice: Person = {}; // 에러 발생
const bob = {} as Person;  // 에러 없음

// 타입 선언은 할당되는 값이 인터페이스를 만족하는지 검사하지만 타입선언은 그 오류를 무시하게 함
```

- 화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있습니다.

```ts
interface Person { name: string };
const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// Person 배열을 원했지만 결과는 { name: string; }[]
```

- 화살표 함수의 반환 타입을 선언해서 원하는 타입을 명시할 수 있습니다. 

```ts
interface Person { name: string };
const people = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
); // 타입은 Person[]
```

- DOM엘리먼트에 대해서는 타입 단언이 꼭 필요합니다.

```ts
document.querySelector('#myButton').addEventListener('click', e => {
  //e.currentTarget // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
});
```
> 타입스크립트는 DOM에 접근할 수 없기 때문에 `#myButton`이 버튼 엘리먼트인지 알지 못합니다.
> 그리고 이벤트의 `currentTarget`이 같은 버튼이어야 하는 것도 알지 못합니다.

- 변수의 `!`는 boolean 의 부정문으로 사용되고 접미사로 쓰인 경우는 그 값이 `null`이 아니라는 단언문으로 사용됩니다.

```ts
const elNull = document.getElementById('foo');  // 타입은 HTMLElement | null
const el = document.getElementById('foo')!; // 타입은 HTMLElement
```

> `!`는 단언문으로 생각하고 사용해야 합니다. 단언문은 컴파일할때 제거되므로 그 값이 `null`이 아니라고 확신할 수 있을 때 사용해야 합니다.

- `unknown` 타입은 모든 타입의 서브타입이 때문에 `unknown`이 포함된 단언문은 항상 동작합니다.

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person; // 에러, 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은 형식이 다른 형식과 충분히 겹치지 않기 때문에 실수 일 수 있습니다. 

const noError = document.body as unknown as Person;  // 타입체크 통과
```
> `unknown` 단언은 임의의 타이간에 변환을 가능하게 하지만 이것은 무언가 위험한 동작을 하고 있다는걸 알 수 있습니다.

### 객체 래퍼 타입 피하기




### 잉여 속성 체크의 한계 인지하기



## 💡 생각

- 타입 단언은 필요한 경우를 잘 가려서 사용하자.






