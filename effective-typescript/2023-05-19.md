# TIL / 2장 타입스크립트의 타입 시스템 part.2 / 2023.05.19

## 🍎 오늘 읽은 내용

- 아이템 9: 타입 단언 보다는 타입 선언을 사용하기
- 아이템 10: 객체 래퍼 타입 피하기
- 아이템 11: 잉여 속성 체크의 한계 인지하기

## 📔 메모

### 타입 단언 보다는 타입 선언을 사용하기

- 타입선언을 사용하는것이 더 나은 이유는 아래와 같습니다.

```ts
interface Person { name: string };
const alice: Person = {}; // 에러 발생
const bob = {} as Person;  // 에러 없음

// 타입 선언은 할당되는 값이 인터페이스를 만족하는지 검사하지만 타입선언은 그 오류를 무시하게 함
```

- 화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있습니다.

```ts
interface Person { name: string };
const people = ['alice', 'bob', 'jan'].map(name => ({name}));
// Person 배열을 원했지만 결과는 { name: string; }[]
```

- 화살표 함수의 반환 타입을 선언해서 원하는 타입을 명시할 수 있습니다. 

```ts
interface Person { name: string };
const people = ['alice', 'bob', 'jan'].map(
  (name): Person => ({name})
); // 타입은 Person[]
```

- DOM엘리먼트에 대해서는 타입 단언이 꼭 필요합니다.

```ts
document.querySelector('#myButton').addEventListener('click', e => {
  //e.currentTarget // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
});
```
> 타입스크립트는 DOM에 접근할 수 없기 때문에 `#myButton`이 버튼 엘리먼트인지 알지 못합니다.
> 그리고 이벤트의 `currentTarget`이 같은 버튼이어야 하는 것도 알지 못합니다.

- 변수의 `!`는 boolean 의 부정문으로 사용되고 접미사로 쓰인 경우는 그 값이 `null`이 아니라는 단언문으로 사용됩니다.

```ts
const elNull = document.getElementById('foo');  // 타입은 HTMLElement | null
const el = document.getElementById('foo')!; // 타입은 HTMLElement
```

> `!`는 단언문으로 생각하고 사용해야 합니다. 단언문은 컴파일할때 제거되므로 그 값이 `null`이 아니라고 확신할 수 있을 때 사용해야 합니다.

- `unknown` 타입은 모든 타입의 서브타입이 때문에 `unknown`이 포함된 단언문은 항상 동작합니다.

```ts
interface Person { name: string; }
const body = document.body;
const el = body as Person; // 에러, 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은 형식이 다른 형식과 충분히 겹치지 않기 때문에 실수 일 수 있습니다. 

const noError = document.body as unknown as Person;  // 타입체크 통과
```
> `unknown` 단언은 임의의 타이간에 변환을 가능하게 하지만 이것은 무언가 위험한 동작을 하고 있다는걸 알 수 있습니다.

### 객체 래퍼 타입 피하기

- 자바스크립트의 기본형들은 불변이며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다.
- 그런데 기본형인 `string`의 경우 메서드를 가지고 있는 것처럼 보입니다.

```ts
'primitive'.charAt(3) //"m"
```

> `charAt`은 `string`의 메서드가 아니며, `string` 을 사용할 때 자바스크립트 내부적으로 많은 동작이 일어납니다.
> `string`기본형은 메서드가 없지만 메서드를 가지는 `String`객체 타입이 정의되어 있고 자바스크립트는 기본형과 객체타입을 자유롭게 변환합니다.
> 자바스크립트는 기본형을 `String` 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버립니다.

- 만약 `String.prototype`을 **몽키패치(monkye-patch)** 한다면 앞서 설명한 내부적인 동작들을 관찰할 수 있습니다.

```ts
// 실제로는 이렇게 하지 마세요!
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function(pos) {
  console.log(this, typeof this, pos);
  return originalCharAt.call(this, pos);
}
console.log("primitive".charAt(3));
```

위 코드는 다음을 출력합니다.

`[String: "primitive"] "object" 3`

> 메서드 내의 `this`는 `string` 기본형이 아닌 `String` 객체 래퍼입니다. 
> `String` 객체 래퍼는 `String` 객체를 직접 생성할 수도 있으며, `string`기본형처럼 동작합니다.
> 기본형 객체 래퍼는 항상 동일하게 동작하지 않습니다. 예를 들어, `String` 객체는 오직 자기 자신하고만 동일합니다.

```ts
"hello" === new String("hello") // false
new String("hello") === new String("hello") // false
String === String // true
```

- 객체 래퍼 타입의 자동 변환은 당황스러운 동작을 보일 때가 있습니다. 예를 들어 어떤 속성을 기본형에 할당했을 때 그 속성이 사라집니다.

```ts
x = "hello";
x.language = "English"
x.language // undefined
```

> 실제로는 `x`가 `String` 객체로 변환된 후 `language` 속성이 추가되었고, `language` 속성이 추가된 객체는 버려진 것입니다.
> 다른 기본형에도 동일하게 객체 래퍼 타입이 존재합니다.
> 이 래퍼타입들 덕분에 기본형 값에 메서드를 사용할 수 있고, 정적 메서드(`String.fromCharCode` 같은)도 사용할 수 있습니다.
> 그러나 보통은 래퍼객체를 직접 생성할 필요가 없습니다.

타입 스크립트는 기본형과 객체 래퍼 타입을 별도로 모델링 합니다.

```md
string 과 String
number 와 Number
boolean 과 Boolean
symbol 과 Symbol
bigint 와 BigInt
```

- `string`을 사용할 때는 특히 유의해야 하는데, `string`을 `String`이라고 잘못 타이핑하더라도 처음에는 잘 동작하는 것처럼 보이기 때문입니다.

```ts
function getStringLen(foo: String) {
  return foo.length;
}

getStringLen("hello"); // 정상
getStringLen(new String("hello")); // 정상
```
그러나 `string`을 매개변수로 받는 메서드에 `String` 객체를 전달하는 순간 문제가 발생합니다.

```ts
function isGreeting(phrase: String) {
  return [
    'hello',
    'good day'
  ].includes(phrase);
} 
// 'String' 형식의 인수는 'string' 형식의 매개변수에 할당할 수 없습니다.
// 'string' 은(는) 기본 개체이지만 'String'은(는) 래퍼 개체입니다.
// 가능한 경우 'string'을(를) 사용하세요.
```

> `string`은 `String`에 할당할 수 있지만 `String`은 `string`에 할당할 수 없습니다.


### 잉여 속성 체크의 한계 인지하기



## 💡 생각

- 타입 단언은 필요한 경우를 잘 가려서 사용하자.
- 객체래퍼 타입은 가능한 가용하지 말자.


















































